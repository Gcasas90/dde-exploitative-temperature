#!/usr/bin/env python
# -*- coding: utf-8 -*-
'''
Host-parasitoid model with variable developmental delays.
'''

import argparse
import json
from numpy import *
import os
from PyDDE import pydde
from scipy.integrate import odeint
import time

parser = argparse.ArgumentParser(description='Description of this module',
                                 prog="PROGRAM_NAME",
                                 epilog="epilog test text")
parser.add_argument('-p',
                    action = 'store',
                    dest = 'parfile',
                    help = 'parameter file name',
                    required = True)
parser.add_argument('-v',
                    action = 'store',
                    default = None,
                    dest = 'varfile',
                    help = 'variable parameters file name')
parser.add_argument('-n',
                    action = 'store',
                    default = 0,
                    dest = 'N',
                    help = 'variable parameters index',
                    type = int)
parser.add_argument('-y',
                    action = 'store',
                    default = 100,
                    dest = 'nyrs',
                    help = 'Number of years of simulation',
                    type = float)
parser.add_argument('-b',
                    action = 'store',
                    default = 8,
                    dest = 'hbsize',
                    help = 'Memory buffer exponent',
                    type = int)
parser.add_argument('-q',
                    action = 'store_true',
                    dest = 'qleft',
                    help = 'Consumers attack adult resources')
parser.add_argument('-a',
                    action = 'store_true',
                    dest = 'adultresource',
                    help = 'Consumers attack adult resources')
parser.add_argument('-u',
                    action = 'store_true',
                    dest = 'unstructured',
                    help = 'No juvenile stage')
parser.add_argument('-o',
                    action = 'store',
                    dest = 'output',
                    default = 'hosttwopar',
                    help = 'output file name')
parser.add_argument('-O',
                    action = 'store_true',
                    dest = 'overwrite',
                    help = 'overwrite save files')
parser.add_argument('-i',
                    action = 'store',
                    default = 'coex',
                    dest = 'init',
                    help = 'initial conditions: coex, inv1, inv2, pair1, pair2, res')
parser.add_argument('-D',
                    action = 'store_false',
                    dest = 'deathtemp',
                    help = 'disable mortality temperature sensitivity')

args = parser.parse_args()

with open(args.parfile) as f:
    param = json.load(f)

if (args.varfile != None):
    with open(args.varfile) as f:
        dimensions, axis = json.load(f)

    k = int(args.N)
    n = []
    for i in range(len(dimensions)):
        n.append(k % dimensions[i])
        k = int(k/dimensions[i])

    for dim, parameters in enumerate(axis):
        nsteps = n[dim]
        for p in parameters:
            par, pmin, pmax = p
            stepsize = (pmax-pmin)/(dimensions[dim]-1.)
            parval = pmin + stepsize*nsteps
        
            args.output += "_"+par+"_"+str(parval)
            param[par] = parval

## Set initial conditions
if (args.init=="coex"):
    print("Initial conditions coexistence")
    init = [1.0, 1.0, 1.0]
elif (args.init=="inv1"):
    print("Initial conditions P1 invasion")
    init = [1.0, 0.001, 1.0]
elif (args.init=="inv2"):
    print("Initial conditions P2 invasion")
    init = [1.0, 1.0, 0.001]
elif (args.init=="pair1"):
    print("Initial conditions R-P1 pairwise")
    init = [1.0, 1.0, 0.0]
elif (args.init=="pair2"):
    print("Initial conditions R-P2 pairwise")
    init = [1.0, 0.0, 1.0]
elif (args.init=="res"):
    print("Initial conditions R only")
    init = [1.0, 0.0, 0.0]
else:
    print("Error: Unrecognized initial state: "+args.init)
    exit()

# Temperature response functions
def boltzmann_arrhenius(kTr, Ak, Tr, AkL, TrL, T):
    return kTr * exp(Ak * (1./Tr - 1./T)) * (1.+exp(AkL*(1./TrL-1./T)))

#def sharpe_schoolfield(kTr, A, Tr, AL, TL, AH, TH, T):
#    return kTr * T/Tr * exp(A * (1./Tr - 1./T)) / \
#        (1.+exp(AL*(1./TL-1./T))+exp(AH*(1./TH-1./T)))

def sharpe_schoolfield(kTr, A, Tr, AL, TL, AH, TH, T):
    return kTr * T/Tr * exp(A * (1./Tr - 1./T)) / (1.+exp(AL*(1./TL-1./T))+exp(AH*(1./TH-1./T)))

def sharpe_schoolfield_warm(kTr, A, Tr, AH, TH, T):
    return kTr * T/Tr * exp(A * (1./Tr - 1./T)) / (1.+exp(AH*(1./TH-1./T)))

def gaussian(kTr, Topt, s, T):
    return kTr * exp(-(T-Topt)**2/2./s**2)

def invgaussian(kTr, Topt, s, T):
    return kTr * exp((T-Topt)**2/2./s**2)

# density dependence
def unimodal(t):
    return gaussian(qTopt, Toptq, qs, T(t))
def monotonic(t):
    return boltzmann_arrhenius(qTR, Aq, TR, T(t))
def constant(t):
    return qTR

#Seasonal variation in temperature 
meanT = param["MT"]#273. + 17.22
amplT = param["AT"]#6.5

#Parameter values for host species 
bTopt = param["bTopt"]
Toptb = param["Toptb"]
sb = param["sb"]

dATR = param["dATR"]
AdA = param["AdA"]
TRdA = param["TRdA"]
ALdA = param["ALdA"]
TLdA = param["TLdA"]

dETR = param["dETR"]
AdE = param["AdE"]
TRdE = param["TRdE"]
ALdE = param["ALdE"]
TLdE = param["TLdE"]

mE = param["mE"]
TRE = param["TRE"]
TLE = param["TLE"]
THE = param["THE"]
AmE = param["AmE"]
ALE = param["ALE"]
AHE = param["AHE"]

#TR = param["TR"]

#Temperature dependence of competition
#Aq = param["Aq"]
if(args.qleft):
    qTR = param["qTR"]
    TRq = param["TRq"]
    Aq = param["Aq"]
    TLq = param["TLq"]
    ALq = param["ALq"]
    THq = param["THq"]
    AHq = param["AHq"]
else:
    qTopt = param["qTopt"]
    Toptq = param["Toptq"]
    sq = param["sq"]

    
# parameter values for parasitoid species 1

if "s1" in param:
    param["a1Topt"] = param["a1Topt"]*(param["sa1"]/param["s1"])
    param["sa1"] = param["s1"]

Topta1 = param["Topta1"]
sa1 = param["sa1"]
a1Topt = param["a1Topt"]

h1Topt = param["h1Topt"]
sh1 = param["sh1"]
Topth1 = param["Topth1"]

e1 = param["e1"]

dP1TR = param["dP1TR"]
AdP1 = param["AdP1"]
TRdP1 = param["TRdP1"]
ALdP1 = param["ALdP1"]
TLdP1 = param["TLdP1"]

dL1TR = param["dL1TR"]
AdL1 = param["AdL1"]
TRdL1 = param["TRdL1"]
ALdL1 = param["ALdL1"]
TLdL1 = param["TLdL1"]

mL1 = param["mL1"]
TRL1 = param["TRL1"]
TLL1 = param["TLL1"]
THL1 = param["THL1"]
AmL1 = param["AmL1"]
ALL1 = param["ALL1"]
AHL1 = param["AHL1"]

## Adjust the lower temperature TLL1 by m1 while keeping the area constant
if "m1" in param:
    aT = arange(meanT - amplT, meanT + amplT, 0.01)
    gL1area = sum(sharpe_schoolfield(mL1, AmL1, TRL1, ALL1, TLL1, AHL1, THL1, aT))
    gL1modarea = sum(sharpe_schoolfield(mL1, AmL1, TRL1, ALL1, TLL1+param["m1"], AHL1, THL1, aT))
    
    param["mL1"] = param["mL1"] * gL1area / gL1modarea
    param["TLL1"] = param["TLL1"] + param["m1"]
    
    mL1 = param["mL1"]
    TLL1 = param["TLL1"]

# parameter values for parasitoid species 2

if "s2" in param:
    param["a2Topt"] = param["a2Topt"]*(param["sa2"]/param["s2"])
    param["sa2"] = param["s2"]

Topta2 = param["Topta2"]
sa2 = param["sa2"]
a2Topt = param["a2Topt"]

h2Topt = param["h2Topt"]
sh2 = param["sh2"]
Topth2 = param["Topth2"]

e2 = param["e2"]

mL2 = param["mL2"]
TRL2 = param["TRL2"]
TLL2 = param["TLL2"]
THL2 = param["THL2"]
AmL2 = param["AmL2"]
ALL2 = param["ALL2"]
AHL2 = param["AHL2"]

dL2TR = param["dL2TR"]
AdL2 = param["AdL2"]
TRdL2 = param["TRdL2"]
ALdL2 = param["ALdL2"]
TLdL2 = param["TLdL2"]

dP2TR = param["dP2TR"]
AdP2 = param["AdP2"]
TRdP2 = param["TRdP2"]
ALdP2 = param["ALdP2"]
TLdP2 = param["TLdP2"]

## Adjust the lower temperature TLL2 by m2 while keeping the area constant
if "m2" in param:
    aT = arange(meanT - amplT, meanT + amplT, 0.01)
    gL2area = sum(sharpe_schoolfield(mL2, AmL2, TRL2, ALL2, TLL2, AHL2, THL2, aT))
    gL2modarea = sum(sharpe_schoolfield(mL2, AmL2, TRL2, ALL2, TLL2+param["m2"], AHL2, THL2, aT))
    
    param["mL2"] = param["mL2"] * gL2area / gL2modarea
    param["TLL2"] = param["TLL2"] + param["m2"]
    
    mL2 = param["mL2"]
    TLL2 = param["TLL2"]

yr = 365.00
tmax = yr*args.nyrs

times = arange(0.0, tmax, 1.)

with open(args.output+".json", "w") as f:
    f.write(json.dumps(param, indent = 2))

# temperature in K as a function of time in days
def T(t):
    #return meanT
    if t < 0:
        return meanT
    return meanT - amplT*cos(2*pi*t/yr)

## life history functions
# fecundity
def b(t):
    return gaussian(bTopt, Toptb, sb, T(t))

# resource competition strength
if(args.qleft):
    def q(t):
        return sharpe_schoolfield(qTR, Aq, TRq, ALq, TLq, AHq, THq, T(t))
        #return sharpe_schoolfield_warm(qTR, Aq, TRq, AHq, THq, T(t))
    print("Using Sharpe-Schoolfield competition response")
else:
    def q(t):
        return gaussian(qTopt, Toptq, sq, T(t))

# parasitoid attack rates
def a1(t):
    return gaussian(a1Topt, Topta1, sa1, T(t))
#    return boltzmann_arrhenius(a1TR, Aa1, TR, T(t))

def a2(t):
    return gaussian(a2Topt, Topta2, sa2, T(t))
#    return boltzmann_arrhenius(a2TR, Aa2, TR, T(t))

# parasitoid handling times
def h1(t):
    #return h1Topt
    return invgaussian(h1Topt, Topth1, sh1, T(t))

def h2(t):
    #return h2Topt
    return invgaussian(h2Topt, Topth2, sh2, T(t))

# death rates
if (args.deathtemp):
    #print("Death rate using Boltzmann-Arrhenius TRC")
    # host
    def dE(t):
        return boltzmann_arrhenius(dETR, AdE, TRdE, ALdE, TLdE, T(t))
    def dA(t):
        return boltzmann_arrhenius(dATR, AdA, TRdA, ALdA, TLdA, T(t))
    # parasitoid 1
    def dL1(t):
        return boltzmann_arrhenius(dL1TR, AdL1, TRdL1, ALdL1, TLdL1, T(t))
    def dP1(t):
        return boltzmann_arrhenius(dP1TR, AdP1, TRdP1, ALdP1, TLdP1, T(t))
    # parasitoid 2
    def dL2(t):
        return boltzmann_arrhenius(dL2TR, AdL2, TRdL2, ALdL2, TLdL2, T(t))
    def dP2(t):
        return boltzmann_arrhenius(dP2TR, AdP2, TRdP2, ALdP2, TLdP2, T(t))
else:
    print("Mortality temperature sensitivity disabled, using mortality at mean temperature")
    Tmort = 292.
    dETmort = boltzmann_arrhenius(dETR, AdE, TRdE, ALdE, TLdE, Tmort)
    dATmort = boltzmann_arrhenius(dATR, AdA, TRdA, ALdA, TLdA, Tmort)
    dL1Tmort = boltzmann_arrhenius(dL1TR, AdL1, TRdL1, ALdL1, TLdL1, Tmort)
    dP1Tmort = boltzmann_arrhenius(dP1TR, AdP1, TRdP1, ALdP1, TLdP1, Tmort)
    dL2Tmort = boltzmann_arrhenius(dL2TR, AdL2, TRdL2, ALdL2, TLdL2, Tmort)
    dP2Tmort = boltzmann_arrhenius(dP2TR, AdP2, TRdP2, ALdP2, TLdP2, Tmort)

    def dE(t):
        return dETmort
    def dA(t):
        return dATmort
    # parasitoid 1
    def dL1(t):
        return dL1Tmort
    def dP1(t):
        return dP1Tmort
    # parasitoid 2
    def dL2(t):
        return dL2Tmort
    def dP2(t):
        return dP2Tmort

# maturation rates
# host
def gE(t):
    return sharpe_schoolfield(mE, AmE, TRE, ALE, TLE, AHE, THE, T(t))
    #return sharpe_schoolfield(mE, AmE, TRE, AHE, THE, T(t))
# parasitoid 1
def gL1(t):
    return sharpe_schoolfield(mL1, AmL1, TRL1, ALL1, TLL1, AHL1, THL1, T(t))
    #return sharpe_schoolfield(mL1, AmL1, TRL1, AHL1, THL1, T(t))
# parasitoid 2
def gL2(t):
    return sharpe_schoolfield(mL2, AmL2, TRL2, ALL2, TLL2, AHL2, THL2, T(t))
    #return sharpe_schoolfield(mL2, AmL2, TRL2, AHL2, THL2, T(t))

dde_eg = pydde.dde()   

def unstructured_ode(tol=1e-8, dd='fec'):

    print("Exploitative competition ODE")

    # density dependence
    def qb(x, t): return 1
    def qd(x, t): return 1

    if(dd == 'fec'):
        def qb(x, t):
            return exp(-x*q(t))
    elif(dd == 'mort'):
        def qd(x, t):
            return (1+x*q(t))

    # resource birth rate
    def rho(x, t):
        return b(t)*x*qb(x,t)

    # initial condition
    odeist = array([init[0], init[1], init[2]])

    def odegrad(s, t):
        return array([rho(s[0], t) - (a1(t)*s[0]*s[1])/(1+a1(t)*h1(t)*s[0]) \
                      - (a2(t)*s[0]*s[2])/(1+a2(t)*h2(t)*s[0]) - dA(t)*s[0], # A s[0]
            (e1*a1(t)*s[0]*s[1])/(1+a1(t)*h1(t)*s[0]) - dP1(t)*s[1], # P1 s[1]
            (e2*a2(t)*s[0]*s[2])/(1+a2(t)*h2(t)*s[0]) - dP2(t)*s[2] # P2 s[2]
        ])

    data = odeint(odegrad, odeist, times)
    t = reshape(times, (len(times), 1))
    print(t.shape, data.shape)
    return concatenate((t, data), axis=1)

def unstructured_log_ode(tol=1e-8, hbsize=None, dd='fec'):

    print("Exploitative competition ODE")

    # density dependence
    def qb(x, t): return 1
    def qd(x, t): return 1

    if(dd == 'fec'):
        def qb(x, t):
            return exp(-x*q(t))
    elif(dd == 'mort'):
        def qd(x, t):
            return (1+x*q(t))

    # resource birth rate
    def rho(x, t):
        return b(t)*qb(x,t)

    if(init[1] > 0 and init[2] > 0):
        # initial condition
        odeist = array([log(init[0]), log(init[1]), log(init[2])])

        def odegrad(s, t):
            es = exp(s)
            return array([rho(es[0], t) - (a1(t)*es[1])/(1+a1(t)*h1(t)*es[0]) \
                          - (a2(t)*es[2])/(1+a2(t)*h2(t)*es[0]) - dA(t), # log(A) es[0]
                (e1*a1(t)*es[0])/(1+a1(t)*h1(t)*es[0]) - dP1(t), # log(P1) es[1]
                (e2*a2(t)*es[0])/(1+a2(t)*h2(t)*es[0]) - dP2(t) # log(P2) es[2]
            ])
    elif(init[1] > 0):
        # initial condition
        odeist = array([log(init[0]), log(init[1]), 0])

        def odegrad(s, t):
            es = exp(s)
            return array([rho(es[0], t) - (a1(t)*es[1])/(1+a1(t)*h1(t)*es[0]) - dA(t), # log(A) es[0]
                (e1*a1(t)*es[0])/(1+a1(t)*h1(t)*es[0]) - dP1(t), # log(P1) es[1]
                0 # log(P2) es[2]
            ])
    elif(init[2] > 0):
        # initial condition
        odeist = array([log(init[0]), 0, log(init[2])])

        def odegrad(s, t):
            es = exp(s)
            return array([rho(es[0], t) - (a2(t)*es[2])/(1+a2(t)*h2(t)*es[0]) - dA(t), # log(A) es[0]
                0, # log(P1) es[1]
                (e2*a2(t)*es[0])/(1+a2(t)*h2(t)*es[0]) - dP2(t) # log(P2) es[2]
            ])
    else:
        # initial condition
        odeist = array([log(init[0]), 0, 0])

        def odegrad(s, t):
            es = exp(s)
            return array([rho(es[0], t) - dA(t), # log(A) es[0]
                0, # log(P1) es[1]
                0 # log(P2) es[2]
            ])

    data = odeint(odegrad, odeist, times)
    t = reshape(times, (len(times), 1))
    data[:, 0] = exp(data[:, 0])
    if (init[1] > 0):
        data[:, 1] = exp(data[:, 1])
    if (init[2] > 0):
        data[:, 2] = exp(data[:, 2])
    return concatenate((t, data), axis=1)

def juvenile_resource_dde(tol=1e-8, hbsize=1e8, dd='fec'):

    print("Juvenile resource DDE")

    # density dependence
    def qb(x, t): return 1
    def qd(x, t): return 1

    if(dd == 'fec'):
        def qb(x, t):
            return exp(-x*q(t))
    elif(dd == 'mort'):
        def qd(x, t):
            return (1+x*q(t))

    # resource birth rate
    def rho(x, t):
        return b(t)*x*qb(x,t)

    # initial condition
    ddeist = array([ 0., init[0], 0., init[1], 0., init[2], exp(-dE(-1e-3)/mE), exp(-dL1(-1e-3)/mL1), exp(-dL2(-1e-3)/mL2), 1./mE, 1./mL1, 1./mL2])

    def ddegrad(s, parms, t):
        # constant past history
        Et1 = EtL1 = EtL2 = Nt1 = At1 = At2 = P1t1 = P2t1 = PtE1 = PtE2 = 0.
        ME = MN = ML1 = ML2 = 0.
        St1 = ddeist[7]
        taut1 = ddeist[11]

        if t > s[9]:
            Et1 = pydde.pastvalue(0, t-s[9], 0)
            At1 = pydde.pastvalue(1, t-s[9], 0)
            PtE1 = pydde.pastvalue(3, t-s[9], 0)
            PtE2 = pydde.pastvalue(5, t-s[9], 0)

        if t > s[10]:
            EtL1 = pydde.pastvalue(0, t-s[10], 0)
            P1t1 = pydde.pastvalue(3, t-s[10], 0)

        if t > s[11]:
            EtL2 = pydde.pastvalue(0, t-s[11], 0)
            P2t1 = pydde.pastvalue(5, t-s[11], 0)


        if t > s[9]:
            ME = rho(At1, t-s[9]) * gE(t)/gE(t-s[9]) * s[6]

        if t > s[10]:
            ML1 = (e1*a1(t-s[10])*EtL1*P1t1)/(1+a1(t-s[10])*h1(t-s[10])*EtL1)* \
                    gL1(t)/gL1(t-s[10])*s[7]

        if t > s[11]:
            ML2 = (e2*a2(t-s[11])*EtL2*P2t1)/(1+a2(t-s[11])*h2(t-s[11])*EtL2)* \
                    gL2(t)/gL2(t-s[11])*s[8]

        return array([
            # densities
            rho(s[1], t) - ME - (a1(t)*s[0]*s[3])/(1+a1(t)* \
            h1(t)*s[0]) - (a2(t)*s[0]*s[5])/(1+a2(t)*h2(t)*s[0]) - dE(t)*s[0]*qd(t, s[0]) , # E s[0]

            #ME - MN - dN(t) * s[1], # N

            ME - dA(t)*s[1], # A s[1]

            (e1*a1(t)*s[0]*s[3])/(1+a1(t)*h1(t)*s[0]) - ML1 - dL1(t)*s[2], # L1 s[2]

            ML1 - dP1(t)*s[3], # P1 s[3]

            (e2*a2(t)*s[0]*s[5])/(1+a2(t)*h2(t)*s[0]) - ML2 - dL2(t)*s[4], # L2 s[4]

            ML2 - dP2(t)*s[5], # P2 s[5]

            # through-stage survivals
            s[6] * ( gE(t)/gE(t-s[9]) * (dE(t-s[9])*qd(t-s[9], Et1) + \
                    (a1(t-s[9])*PtE1)/(1+a1(t-s[9])*h1(t-s[9])*Et1) + \
                    (a2(t-s[9])*PtE2)/(1+a2(t-s[9])*h2(t-s[9])*Et1))\
                    - (dE(t)*qd(t, s[0]) + \
                    (a1(t)*s[3])/(1+a1(t)*h1(t)*s[0]) + \
                    (a2(t)*s[5])/(1+a2(t)*h2(t)*s[0]) )), # S_E s[6]

            s[7] * (gL1(t) * dL1(t-s[10])/gL1(t-s[10]) - dL1(t)), # S_L1 s[7]

            s[8] * (gL2(t) * dL2(t-s[11])/gL2(t-s[11]) - dL2(t)), # S_L2 s[8]

            # time delays
            1. - gE(t)/gE(t-s[9]), # tau_E s[9]
            1. - gL1(t)/gL1(t-s[10]), # tau_L1 s[10]
            1. - gL2(t)/gL2(t-s[11]), # tau_L2 s[11]
            ])
            
   
    # finally the integration routine
    dde_eg.dde(y=ddeist, times=times,
           func=ddegrad, parms=(),
           tol=tol, hbsize=hbsize, 
           nlag=13)

    return dde_eg.data

def adult_resource_dde(tol=1e-8, hbsize=1e8, dd='fec'):

    print("Adult resource DDE")
    
    # density dependence
    def qb(x, t): return 1
    def qd(x, t): return 1

    if(dd == 'fec'):
        def qb(x, t):
            return exp(-x*q(t))
    elif(dd == 'mort'):
        def qd(x, t):
            return (1+x*q(t))
    
    # resource birth rate
    def rho(x, t):
        return b(t)*x*qb(x,t)

# initial condition
    ddeist = array([ 0., init[0], 0., init[1], 0., init[2], exp(-dE(-1e-3)/mE), exp(-dL1(-1e-3)/mL1), exp(-dL2(-1e-3)/mL2), 1./mE, 1./mL1, 1./mL2])

    def ddegrad(s, parms, t):

        # constant past history
        Et1 = EtL1 = EtL2 = Nt1 = At1 = At2 = P1t1 = P2t1 = PtE1 = PtE2 = 0.
        ME = MN = ML1 = ML2 = 0.
        St1 = ddeist[7]
        taut1 = ddeist[11]

        if t > s[9]:
            Et1 = pydde.pastvalue(0, t-s[9], 0)
            At1 = pydde.pastvalue(1, t-s[9], 0)
            PtE1 = pydde.pastvalue(3, t-s[9], 0)
            PtE2 = pydde.pastvalue(5, t-s[9], 0)

        if t > s[10]:
            AtL1 = pydde.pastvalue(1, t-s[10], 0)
            P1t1 = pydde.pastvalue(3, t-s[10], 0)

        if t > s[11]:
            AtL2 = pydde.pastvalue(1, t-s[11], 0)
            P2t1 = pydde.pastvalue(5, t-s[11], 0)


        if t > s[9]:
            ME = rho(At1, t-s[9]) * gE(t)/gE(t-s[9]) * s[6]

        if t > s[10]:
            ML1 = (e1*a1(t-s[10])*AtL1*P1t1)/(1+a1(t-s[10])*h1(t-s[10])*AtL1)* \
                    gL1(t)/gL1(t-s[10])*s[7]

        if t > s[11]:
            ML2 = (e2*a2(t-s[11])*AtL2*P2t1)/(1+a2(t-s[11])*h2(t-s[11])*AtL2)* \
                    gL2(t)/gL2(t-s[11])*s[8]

        return array([
            # densities
            rho(s[1], t) - ME - dE(t)*s[0]*qd(t, s[0]) , # E s[0]

            #ME - MN - dN(t) * s[1], # N

            ME - dA(t)*s[1] - (a1(t)*s[1]*s[3])/(1+a1(t)*h1(t)*s[1]) \
            - (a2(t)*s[1]*s[5])/(1+a2(t)*h2(t)*s[1]), # A s[1]

            (e1*a1(t)*s[1]*s[3])/(1+a1(t)*h1(t)*s[1]) - ML1 - dL1(t)*s[2], # L1 s[2]

            ML1 - dP1(t)*s[3], # P1 s[3]

            (e2*a2(t)*s[1]*s[5])/(1+a2(t)*h2(t)*s[1]) - ML2 - dL2(t)*s[4], # L2 s[4]

            ML2 - dP2(t)*s[5], # P2 s[5]

            # through-stage survivals
            s[6]* (gE(t) * dE(t-s[10])/gE(t-s[10]) - dE(t)), # S_E s[6]

            s[7] * (gL1(t) * dL1(t-s[10])/gL1(t-s[10]) - dL1(t)), # S_L1 s[7]

            s[8] * (gL2(t) * dL2(t-s[11])/gL2(t-s[11]) - dL2(t)), # S_L2 s[8]

            # time delays
            1. - gE(t)/gE(t-s[9]), # tau_E s[9]
            1. - gL1(t)/gL1(t-s[10]), # tau_L1 s[10]
            1. - gL2(t)/gL2(t-s[11]), # tau_L2 s[11]
            ])
            
   
    # finally the integration routine
    dde_eg.dde(y=ddeist, times=times,
           func=ddegrad, parms=(),
           tol=tol, hbsize=hbsize, 
           nlag=13)

    return dde_eg.data

if(args.unstructured):
    solve_de = unstructured_log_ode
    print("Using unstructured model")
    tolerance = 1e-8
elif(args.adultresource):
    solve_de = adult_resource_dde
    tolerance = 1e-8
else:
    solve_de = juvenile_resource_dde
    tolerance = 1e-8

## If not in overwirte mode, checks if simulation was already done, if so skips it
outfile = args.output+".npy"

if(args.overwrite == False):
    try:
        f = open(outfile)
    except IOError:
        cur_time = time.localtime()
        print("%02d:%02d:%02d: Starting simulation %d" % (cur_time.tm_hour, cur_time.tm_min, cur_time.tm_sec, args.N))
        # File doesnt exist, proceed as normal
    else:
        print(outfile+" already exists, skipping simulation")
        exit()
else:
    cur_time = time.localtime()
    print("%02d:%02d:%02d: Starting simulation %d" % (cur_time.tm_hour, cur_time.tm_min, cur_time.tm_sec, args.N))

start_time = time.clock()
data = solve_de(tol=tolerance, hbsize=10**args.hbsize, dd='fec')
end_time = time.clock()

run_time = end_time-start_time
run_h = int(run_time/3600)
run_min = int((run_time%3600)/60)
run_sec = run_time%60

cur_time = time.localtime()
print("%02d:%02d:%02d: Simulation %d complete in %dh %dmin %fsec\n" % (cur_time.tm_hour, cur_time.tm_min, cur_time.tm_sec, args.N, run_h, run_min, run_sec))

save(args.output+".npy", data)
